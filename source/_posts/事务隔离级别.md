---
title: 事务隔离级别
date: 2019-04-19 20:08:50
tags:
---

记录一下事务的隔离级别

<!-- more -->

# 基本语句

`set [session|global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}`:设置事务隔离级别

`select @@global.tx_isolation`:`global`可以去掉或者改成`session`

mysql默认的隔离级别是`repeatable read`

# 各个级别会出现的问题

隔离级别 | 脏读(Dirty Read) | 不可重复读(NonRepeatable Read) | 幻读(Phantom Read) 
--- | --- | --- | ---
读未提交(Read Uncommitted) | 可能 | 可能 | 可能
读已提交(Read Committed) | 不可能 | 可能 | 可能
可重复读(Repeatable Read) | 不可能 | 不可能 | 可能
可串行化(Serializable) | 不可能 | 不可能 | 不可能


# 例子

t_user表

uid | money
--- | ---
1 | 1 
2 | 1
3 | 2

两个客户端:c1,c2

## 脏读 

两个事务同时开启,其中一个事务对表中数据进行了修改,但未提交.这时被另外一个事务查询到了.即读到了未提交的`脏数据`

c1:

`select @@tx_isolation;`

@@tx_isolation
---
REPEATABLE-READ

`set transaction isolation level read uncommitted;`

c2:

`select @@tx_isolation;`

@@tx_isolation
---
REPEATABLE-READ

c1,c2:`start transaction;`

c2:

`update t_user set money=0 where uid =1;` 

c1: 发生脏读

`select * from t_user;`

uid | money
--- | ---
1 | 0 
2 | 1
3 | 2

## 不可重复读 

继续跟上:c1,c2 :`rollback`

c1: `set session transaction isolation level read committed;`

`select * from t_user;`

uid | money
--- | ---
1 | 1 
2 | 1
3 | 2

c2: `update t_user set money=0 where uid=1;`

c1: `select * from t_user;`(未出现脏读:即读未提交)

uid | money
--- | ---
1 | 1 
2 | 1
3 | 2

c2: `commit;`

c1: `select * from t_user;`(出现不可重复读:即读已提交)

uid | money
--- | ---
1 | 0 
2 | 1
3 | 2


## 幻读

c1: `set session transaction isolation level repeatable read;`

c1,c2:`start transaction;`

c1:`select * from t_user;`

uid | money
--- | ---
1 | 0 
2 | 1
3 | 2

c2:`insert into t_user (uid,money) values (5,5);`

`commit;`

c1:`select * from t_user;`(未出现不可重复读)

uid | money
--- | ---
1 | 0 
2 | 1
3 | 2

c1:`insert into t_user (uid,money) values (5,7);`

`ERROR 1062 (23000): Duplicate entry '5' for key 'PRIMARY'`

c1:`select * from t_user;`(出现幻读)

uid | money
--- | ---
1 | 0 
2 | 1
3 | 2

