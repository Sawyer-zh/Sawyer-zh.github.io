# 一些排序算法
之前总是刻意去记住写法,现在换一个思路. 按照自己的理解去实现.语言无所谓 就用php吧

### 冒泡排序
* 总是记不住两层for循环里面的下标? 等等! 冒泡法不就是两两比较,然后找到最大一个或者最小的一个数吗?那在一个数组里面找最大如何实现?

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
          
        function bubbleSort($array){
            while ($array) {
                find_max($array);
                $ret[]  = array_pop($array);
            }
            return $ret;
        }
        
        #找最大,把最大的排到最后面
        function find_max(&$array){
            for ($i=0; $i < sizeof($array) -1; $i++) { 
                if ($array[$i] > $array[$i+1]) {
                    $tmp = $array[$i];
                    $array[$i] = $array[$i+1];
                    $array[$i+1] = $tmp;
                }
            }   
        }
        
        var_dump(bubbleSort($array));  

* 输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

* 结论:
  
  * 双重循环下标总是傻傻分不清,那就按照自己的理解去实现吧!


### 选择排序
* 选择排序即选择最大或者最小元素的下标.之前也是记的,用双重循环,下标也容易搞错.

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
        
        function selectSort($array){
            while ($array) {
                $idx = selectMax($array);
                $ret[] = $array[$idx];
                array_splice($array, $idx,1);
             }
             return $ret;
        }
        
        function selectMax($array){
            $maxIdx = 0;
            for ($i=1; $i <sizeof($array) ; $i++) { 
                if ($array[$maxIdx] < $array[$i]) {
                    $maxIdx = $i;
                }
            }
            return $maxIdx;
        }
        
        var_dump(selectSort($array));

* 输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

* 结论:

  * 和冒泡排序差别:冒泡排序两两交换,把最大/小的冒出来.而选择排序没有交换,只记录了最大/小的位置


### 插入排序
* 想象一下把一个数字插入到一个有序数组里面,整个数组的插入排序,就是不断把数组中元素取出来,往另外一个数组插入的过程

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
        
        function insertionSort($array){
            while ($array) {
                $needle = array_pop($array);
                insert($needle,$ret);
            }
            return $ret;
        }
        
        function insert($needle,&$haystack){
            for ($i=0; $i <sizeof($haystack) ; $i++) { 
                if ($needle > $haystack[$i]) {
                    break;
                }
            }
        
            for ($j=sizeof($haystack); $j >$i ; $j--) { 
                $haystack[$j] = $haystack[$j-1]; 
            }
        
            $haystack[$i] =$needle;
        }
        
        var_dump(insertionSort($array));

* 输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

* 结论:

  * 把看起来很杂乱的工作抽象出来,封装成一个方法,使思路更加清晰

### 归并排序
* 归并排序采用的是分治算法.分的过程是递归的过程,并的过程是把两个有序数组合并成一个数组的过程

        <?php
        $array = array(6, 5, 3, 1, 8, 7, 2, 4);
        
        function mergeSort($array)
        {
            if (sizeof($array) <= 1) {
                return $array;
            }
        
            $mid = intval(sizeof($array) / 2);
            $left = mergeSort(array_slice($array, 0, $mid));
            $right = mergeSort(array_slice($array, $mid));
            return merge($left, $right);
        }
        
        function merge($left, $right)
        {
            $i = $j = 0;
            while ($i < sizeof($left) && $j < sizeof($right)) {
                if ($left[$i] > $right[$j]) {
                    $ret[] = $left[$i];
                    $i++;
                } else {
                    $ret[] = $right[$j];
                    $j++;
                }
            }
        
            if ($i == sizeof($left)) {
                for ($k = $j; $k < sizeof($right); $k++) {
                    $ret[] = $right[$k];
                }
            }
        
            if ($j == sizeof($right)) {
                for ($k = $i; $k < sizeof($left); $k++) {
                    $ret[] = $left[$k];
                }
            }
            return $ret;
        }
        
        var_dump(mergeSort($array));        

* 输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

* 结论:

  * 递归思路:考虑递归终点,考虑在第i次条件成立的情况下如何得到第i+1次的结果

### 快排
* 选一个数,把比他大的放到左边,比他小的放在右边,然后递归进行下去
        
        <?php
        $array = array(6, 5, 3, 1, 8, 7, 2, 4);
        
        function quickSort($array)
        {
            if (sizeof($array) <= 1) {
                return $array;
            }
            $pivot = array_pop($array);
            foreach ($array as $item) {
                if ($item > $pivot) {
                    $left[] = $item;
                } else {
                    $right[] = $item;
                }
            }
            return array_merge((array) quickSort($left), (array) $pivot, (array) quickSort($right));
        }
        
        var_dump(quickSort($array));  

* 输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

* 结论:

  * 也是用到了递归

### 堆排序
* 利用堆的性质进行排序.以大顶堆为例,父节点大于等于子节点,由此可知根节点为最大值.是完全二叉树,父节点索引为i,则子节点索引为2i+1 和2i+2.根据这两个特性写出堆排序的算法

* 给出两个版本:
  * 1 

        <?php
        
        $array = array(6, 5, 3, 1, 8, 7, 2, 4);
        
        function heapSort($array)
        {
            while ($array) {
                buildHeap($array);
                $ret[] = array_shift($array);
            }
            return $ret;
        }
        
        # 构建一个堆
        function buildHeap(&$array){
            $firstParent = $i = floor(sizeof($array) /2 ) -1;
            while ($i >=0) {
                ajustHeap($array,$i);
                $i--;
            }
        }
        
        # 交换节点 i 使其满足堆的特性
        function ajustHeap(&$array,$i)
        {
            if ($array[2 * $i + 1] < $array[2 * $i + 2]) {
                if ($array[$i] < $array[2 * $i + 2]) {
                    swap($array[$i], $array[2 * $i + 2]);
                }
            } else {
                if ($array[$i] < $array[2 * $i + 1]) {
                    swap($array[$i], $array[2 * $i + 1]);
                }
            }
        }
        
        function swap(&$a, &$b)
        {
            $tmp = $a;
            $a = $b;
            $b = $tmp;
        }
        
        var_dump(heapSort($array));     

  * 2

        <?php
          
        $array = array(6,5,3,1,8,7,2,4);
        
        function heapSort($array){
            buildHeap($array);
            while ($array) {
                swap($array[0] , $array[sizeof($array) -1 ]);
                $ret[] = array_pop($array);
                adjust($array,0);
            }
            return $ret;
        }
        
        # 递归调整 根的位置可能不对的情况
        function adjust(&$array,$i){
            $lastParent =  floor(sizeof($array) / 2) -1;
            if( $i > $lastParent) {
                return;
            }
            
            if ($array[2 * $i + 1] < $array[2 * $i + 2]) {
                if ($array[$i] < $array[2 * $i + 2]) {
                    swap($array[$i], $array[2 * $i + 2]);
                    adjust($array,2 * $i + 2);
                }
            } else {
                if ($array[$i] < $array[2 * $i + 1]) {
                    swap($array[$i], $array[2 * $i + 1]);
                    adjust($array,2 * $i + 1);
                }
            }
        }
        
        function buildHeap(&$array){
            $firstParent = $i =  floor(sizeof($array) / 2) -1;
            while ($i >= 0) {
                adjustHeap($array,$i);
                $i --;      
            }
        }
        
        function adjustHeap(&$array,$i)
        {
            if ($array[2 * $i + 1] < $array[2 * $i + 2]) {
                if ($array[$i] < $array[2 * $i + 2]) {
                    swap($array[$i], $array[2 * $i + 2]);
                }
            } else {
                if ($array[$i] < $array[2 * $i + 1]) {
                    swap($array[$i], $array[2 * $i + 1]);
                }
            }
        }
        
        function swap(&$a, &$b)
        {
            $tmp = $a;
            $a = $b;
            $b = $tmp;
        }
        
        var_dump(heapSort($array));     

* 结论:

  * 方法1:直接构建一个堆,取出最大元素,然后将后面的元素重新构建一个堆.思路清晰,但是发现每次建堆的时候都会遍历所有的父节点, n/2 -1 , (n-1)/2 -1 ,... , 所有加起来应该就是O(n^2)
  * 方法2:先采用方法1建立一个大顶堆, 然后把顶和最后一个元素交换弹出最后一个元素,这样交换并没有改变堆其他元素的相对位置,所以只需要把最顶上的元素依次向下调整即可
  * 调整思路:利用递归,把根的位置和左边或者右边孩子交换,则以这个孩子为根的子树又变成了刚才的情况,而递归的终点则是这个节点已经没有孩子了.显然这样调整最多也就调整了树的高度的次数,所以应该是O(nlogn)