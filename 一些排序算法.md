# 一些排序算法
之前总是刻意去记住写法,现在换一个思路. 按照自己的理解去实现.语言无所谓 就用php吧

### 冒泡排序
总是记不住两层for循环里面的下标? 等等! 冒泡法不就是两两比较,然后找到最大一个或者最小的一个数吗?那在一个数组里面找最大如何实现?

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
          
        function bubbleSort($array){
            while ($array) {
                find_max($array);
                $ret[]  = array_pop($array);
            }
            return $ret;
        }
        
        #找最大,把最大的排到最后面
        function find_max(&$array){
            for ($i=0; $i < sizeof($array) -1; $i++) { 
                if ($array[$i] > $array[$i+1]) {
                    $tmp = $array[$i];
                    $array[$i] = $array[$i+1];
                    $array[$i+1] = $tmp;
                }
            }   
        }
        
        var_dump(bubbleSort($array));  

输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

结论:

        双重循环下标总是傻傻分不清,那就按照自己的理解去实现吧!


### 选择排序
选择排序即选择最大或者最小元素的下标.之前也是记的,用双重循环,下标也容易搞错.

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
        
        function selectSort($array){
            while ($array) {
                $idx = selectMax($array);
                $ret[] = $array[$idx];
                array_splice($array, $idx,1);
             }
             return $ret;
        }
        
        function selectMax($array){
            $maxIdx = 0;
            for ($i=1; $i <sizeof($array) ; $i++) { 
                if ($array[$maxIdx] < $array[$i]) {
                    $maxIdx = $i;
                }
            }
            return $maxIdx;
        }
        
        var_dump(selectSort($array));

输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

结论:

        和冒泡排序差别:冒泡排序两两交换,把最大/小的冒出来.而选择排序没有交换,只记录了最大/小的位置


### 插入排序
想象一下把一个数字插入到一个有序数组里面,整个数组的插入排序,就是不断把数组中元素取出来,往另外一个数组插入的过程

        <?php
        
        $array = array(6,5,3,1,8,7,2,4);
        
        function insertionSort($array){
            while ($array) {
                $needle = array_pop($array);
                insert($needle,$ret);
            }
            return $ret;
        }
        
        function insert($needle,&$haystack){
            for ($i=0; $i <sizeof($haystack) ; $i++) { 
                if ($needle > $haystack[$i]) {
                    break;
                }
            }
        
            for ($j=sizeof($haystack); $j >$i ; $j--) { 
                $haystack[$j] = $haystack[$j-1]; 
            }
        
            $haystack[$i] =$needle;
        }
        
        var_dump(insertionSort($array));

输出:

        array(8) { [0]=> int(8) [1]=> int(7) [2]=> int(6) [3]=> int(5) [4]=> int(4) [5]=> int(3) [6]=> int(2) [7]=> int(1) }

结论:

        把看起来很杂乱的工作抽象出来,封装成一个方法,使思路更加清晰

